<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Pi</title>
    <meta charset="utf-8">
    <style>
      html, body { margin: 0; padding: 0; border: 0; background: #444; }
    </style>
  </head>
  <body>
<div id="o"></div>
<script>

// https://upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Pi-symbol.svg/200px-Pi-symbol.svg.png

var con = console;

function canvas(width, height) {
  var a = document.createElement("canvas");
  document.body.appendChild(a);
  a.width = width;
  a.height = height;
  var c = a.getContext('2d');
  var circleRads = Math.PI * 2;
  c.drawCircle = function(x, y, r) {
    c.arc(x, y, r, 0, circleRads, false);
  }
  c.fillCircle = function(x, y, size, colour) {
    c.beginPath();
    c.fillStyle = colour;
    c.drawCircle(x, y, size);
    c.closePath();
    c.fill();
  }
  return {
    canvas: a,
    ctx: c
  }
}

var out = document.getElementById('o');

var red = "#f00";

var bmp = 800;
var outScale = 0.5;
var outSize = bmp * outScale;
var sw = outSize;
var sh = outSize;

var output = canvas(sw, sh);
var zoomer = canvas(sw, sh);
var test = canvas(sw, sh);
var progress = canvas(sw, sh);

var anim = 0;
var chosenOne = 31;//null;
var modeIndex = 0;
var modes = ["piTime", "piZoom", "circleTime", "circleZoom"];
var mode = modes[modeIndex];
var phaseLength = 100;


function pointInPolygon(point) {

  test.ctx.globalCompositeOperation = 'source-over';
  test.ctx.drawImage(progress.canvas, 0, 0);
  test.ctx.globalCompositeOperation = 'source-in';
  drawGlyph(test.ctx, point, red);

  var pad = 2;

  var size = Math.ceil(point.size + pad);
  var xs = Math.floor(point.x - size);
  var ys = Math.floor(point.y - size);
  size = size * 2;

  var imgd = test.ctx.getImageData(xs, ys, size, size);
  var pixels = imgd.data;

  var ok = true;
  for (var x = 0; x < size && ok; x++) {
    for (var y = 0; y < size && ok; y++) {
      var pixel = (y * size + x) * 4;
      ok = pixels[pixel] === 0;
    }
  }


  test.ctx.globalCompositeOperation = 'source-over';
  test.ctx.fillStyle = ok ? "rgba(0, 0, 255, 0.25)" : "rgba(255, 0, 0, 0.25)";
  test.ctx.fillRect(xs, ys, size, size);

  // con.log(ok);
  return ok;

  // pixels[i  ] = 255 - pix[i  ]; // red
  // pixels[i+1] = 255 - pix[i+1]; // green
  // pixels[i+2] = 255 - pix[i+2]; // blue

}


function newPosition() {
  var pad = 10;
  var x = pad + Math.random() * (sw - pad * 2);
  var y = pad + Math.random() * (sh - pad * 2);
  var minSize = 2;

  var dy = y - sh / 2;
  var dx = x - sw / 2;

  return {
    x: x,
    y: y,
    // rotation: Math.random() > 1.7 ? Math.random() * Math.PI : Math.atan(dy / dx) + Math.PI / 2 + (dx < 0 ? Math.PI : 0),
    // shape: shapes[ ~~(Math.random() * shapes.length) ],
    size: 2 + Math.random() * 10,
    colour: "hsla(100," + ~~(Math.random() * 50 + 10) + "%, " + ~~(Math.random() * 50 + 40) + "%, 1)"
  }
}

function drawGlyph(target, props, colour, chosen) {
  // target.fillCircle(props.x, props.y, props.size, colour);
  var scale = 2 * props.size / bmp;// /  * outScale;
  // con.log(scale);
  target.save();
  target.translate(props.x - props.size, props.y - props.size);


  // if (chosen) {
  //   target.strokeStyle = red;
  //   target.lineWidth = 1;
  //   target.beginPath();
  //   target.fillRect(0, 0, props.size, props.size);
  //   target.closePath();
  //   target.stroke();
  // }

  target.scale(scale, scale);
  target.drawImage(pi, 0, 0);

  target.restore();
}

function generate() {
  var proposed = newPosition();
  var ok = pointInPolygon(proposed);

  var chosen = false;//anim > chosenOne;
  var colour = chosen ? "#F0F" : red;


  if (ok) {
    drawGlyph(output.ctx, proposed, colour, chosen);
    drawGlyph(progress.ctx, proposed, colour, chosen);
  } else {
    // con.log("not ok!");
  }
}


function r() {
  var now = new Date().getTime();
  anim++;
  switch (mode) {
    case "piTime" :
      var iterationsPerFrame = 1;
      for (var i = 0; i < iterationsPerFrame; i++) {
        generate();
      }
      break;
    case "piZoom" :
      var zoomScale = (phaseLength - anim) / phaseLength;
      // con.log("zoom", zoomScale);
      output.ctx.clearRect(0, 0, sw, sh);
      output.ctx.save();
      output.ctx.translate(sw / 2, sh / 2);
      output.ctx.scale(zoomScale, zoomScale);
      output.ctx.translate(- sw / 2, - sh / 2);
      output.ctx.drawImage(zoomer.canvas, 0, 0);
      output.ctx.restore();
  }


  if (anim % phaseLength === 0) {
    modeIndex ++;
    modeIndex %= 1;
    mode = modes[modeIndex];
    zoomer.ctx.drawImage(output.canvas, 0, 0);
    anim = 0;
  }
  // if (anim < 400) 

  var calctime = new Date().getTime() - now;
  out.innerHTML = [mode, anim, calctime];

  requestAnimationFrame(r);

  // setTimeout(r, 1000);
  // if (anim < 400) requestAnimationFrame(r);
}

function drawInverted() {
  progress.ctx.fillStyle = red;
  progress.ctx.fillRect(0, 0, sw, sh);
  progress.ctx.globalCompositeOperation = 'destination-out';
  /*
  progress.ctx.save();
  progress.ctx.scale(outScale, outScale);
  progress.ctx.drawImage(pi, 0, 0);
  progress.ctx.restore();
  */
  progress.ctx.fillCircle(sw / 2, sw / 2, sw / 2);
  progress.ctx.globalCompositeOperation = 'source-over';
}

var piInverted = new Image(), pi = new Image();
pi.onload = function() {
  drawInverted();
  r();
}
pi.src = "pi-red-800.png";


</script>
</body></html>